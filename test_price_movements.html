<!DOCTYPE html>
<html>
<head>
    <title>Price Movement Detection Test</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #0f172a; color: #f1f5f9; }
        #chart-container { width: 800px; height: 400px; margin: 20px 0; }
        .debug { background: #1e293b; padding: 10px; margin: 10px 0; border-radius: 6px; }
        .alert { padding: 8px 12px; margin: 4px 0; border-radius: 4px; font-weight: bold; }
        .alert.spike { background: rgba(34, 197, 94, 0.2); border-left: 4px solid #22c55e; }
        .alert.drop { background: rgba(239, 68, 68, 0.2); border-left: 4px solid #ef4444; }
        .alert.momentum { background: rgba(245, 158, 11, 0.2); border-left: 4px solid #f59e0b; }
    </style>
</head>
<body>
    <h2>Sharp Price Movement Detection Test</h2>
    
    <button onclick="testPriceMovements()">Analyze Price Movements</button>
    
    <div id="alerts-container"></div>
    
    <div id="chart-container">
        <canvas id="price-chart"></canvas>
    </div>
    
    <div id="debug" class="debug">Click button to analyze price movements...</div>
    
    <script>
        let priceChart = null;
        const API_BASE = 'http://localhost:8000';
        
        function detectPriceMovements(candlesticks) {
            const movements = [];
            const alerts = [];
            
            for (let i = 1; i < candlesticks.length; i++) {
                const current = candlesticks[i];
                const previous = candlesticks[i - 1];
                
                // Extract prices
                let currentPrice, previousPrice;
                
                if (current.price && current.price.close !== null) {
                    currentPrice = current.price.close;
                } else if (current.yes_bid && current.yes_ask) {
                    const bid = current.yes_bid.close || current.yes_bid.open;
                    const ask = current.yes_ask.close || current.yes_ask.open;
                    currentPrice = (bid + ask) / 2;
                } else {
                    currentPrice = current.close || 50;
                }
                
                if (previous.price && previous.price.close !== null) {
                    previousPrice = previous.price.close;
                } else if (previous.yes_bid && previous.yes_ask) {
                    const bid = previous.yes_bid.close || previous.yes_bid.open;
                    const ask = previous.yes_ask.close || previous.yes_ask.open;
                    previousPrice = (bid + ask) / 2;
                } else {
                    previousPrice = previous.close || 50;
                }
                
                // Calculate percentage change
                const priceChange = currentPrice - previousPrice;
                const percentChange = previousPrice > 0 ? (priceChange / previousPrice) * 100 : 0;
                
                // Detect significant movements (>2% change)
                const movement = {
                    index: i,
                    timestamp: current.end_period_ts || current.ts,
                    previousPrice: previousPrice,
                    currentPrice: currentPrice,
                    priceChange: priceChange,
                    percentChange: percentChange,
                    volume: current.volume || 0,
                    type: percentChange > 2 ? 'spike' : percentChange < -2 ? 'drop' : 'normal'
                };
                
                movements.push(movement);
                
                // Generate alerts for significant movements
                if (Math.abs(percentChange) >= 2) {
                    const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${i}`;
                    alerts.push({
                        type: movement.type,
                        message: `${movement.type === 'spike' ? 'üìà' : 'üìâ'} ${Math.abs(percentChange).toFixed(1)}% ${movement.type === 'spike' ? 'surge' : 'drop'} at ${timestamp}`,
                        details: `${previousPrice.toFixed(1)}¬¢ ‚Üí ${currentPrice.toFixed(1)}¬¢ (Volume: ${movement.volume.toLocaleString()})`
                    });
                }
            }
            
            // Detect momentum (3+ consecutive moves in same direction)
            let consecutiveUps = 0;
            let consecutiveDowns = 0;
            
            for (let i = 0; i < movements.length; i++) {
                const movement = movements[i];
                
                if (movement.priceChange > 0) {
                    consecutiveUps++;
                    consecutiveDowns = 0;
                    
                    if (consecutiveUps >= 3) {
                        const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${movement.index}`;
                        alerts.push({
                            type: 'momentum',
                            message: `üöÄ Bullish momentum detected at ${timestamp}`,
                            details: `${consecutiveUps} consecutive periods of price increases`
                        });
                        consecutiveUps = 0; // Reset to avoid duplicate alerts
                    }
                } else if (movement.priceChange < 0) {
                    consecutiveDowns++;
                    consecutiveUps = 0;
                    
                    if (consecutiveDowns >= 3) {
                        const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${movement.index}`;
                        alerts.push({
                            type: 'momentum',
                            message: `üìâ Bearish momentum detected at ${timestamp}`,
                            details: `${consecutiveDowns} consecutive periods of price decreases`
                        });
                        consecutiveDowns = 0; // Reset to avoid duplicate alerts
                    }
                }
            }
            
            return { movements, alerts };
        }
        
        async function testPriceMovements() {
            const debugEl = document.getElementById('debug');
            const alertsContainer = document.getElementById('alerts-container');
            
            debugEl.innerHTML = 'Analyzing price movements...';
            alertsContainer.innerHTML = '';
            
            try {
                const marketsResponse = await fetch(`${API_BASE}/markets?limit=1`);
                const marketsData = await marketsResponse.json();
                const ticker = marketsData.markets[0].ticker;
                
                const candleResponse = await fetch(`${API_BASE}/market/${ticker}/candlesticks?period_interval=60&start_days_ago=7`);
                const candleData = await candleResponse.json();
                
                debugEl.innerHTML = `Market: ${ticker}`;
                
                if (candleData.candlesticks && candleData.candlesticks.length > 0) {
                    const candlesticks = candleData.candlesticks;
                    const analysis = detectPriceMovements(candlesticks);
                    
                    debugEl.innerHTML += `<br>Analyzed ${candlesticks.length} periods`;
                    debugEl.innerHTML += `<br>Found ${analysis.alerts.length} significant movements`;
                    
                    // Display alerts
                    if (analysis.alerts.length > 0) {
                        alertsContainer.innerHTML = '<h3>Price Movement Alerts</h3>';
                        analysis.alerts.forEach(alert => {
                            const alertEl = document.createElement('div');
                            alertEl.className = `alert ${alert.type}`;
                            alertEl.innerHTML = `
                                <div>${alert.message}</div>
                                <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 4px;">${alert.details}</div>
                            `;
                            alertsContainer.appendChild(alertEl);
                        });
                    } else {
                        alertsContainer.innerHTML = '<div class="alert">No significant price movements detected</div>';
                    }
                    
                    createMovementChart(candlesticks, analysis.movements, ticker);
                    debugEl.innerHTML += '<br>‚úÖ Movement chart created!';
                } else {
                    debugEl.innerHTML += '<br>‚ùå No candlestick data';
                }
                
            } catch (err) {
                debugEl.innerHTML += `<br>‚ùå Error: ${err.message}`;
            }
        }
        
        function createMovementChart(candlesticks, movements, ticker) {
            const ctx = document.getElementById('price-chart').getContext('2d');
            
            if (priceChart) {
                priceChart.destroy();
            }
            
            const labels = candlesticks.map((candle, index) => {
                const timestamp = candle.end_period_ts || candle.ts;
                if (timestamp) {
                    const date = new Date(timestamp * 1000);
                    if (!isNaN(date.getTime()) && date.getFullYear() >= 2020 && date.getFullYear() <= 2030) {
                        return date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                    }
                }
                return `T-${candlesticks.length - index - 1}h`;
            });
            
            const prices = candlesticks.map(candle => {
                if (candle.price && candle.price.close !== null) {
                    return candle.price.close;
                } else if (candle.yes_bid && candle.yes_ask) {
                    const bid = candle.yes_bid.close || candle.yes_bid.open;
                    const ask = candle.yes_ask.close || candle.yes_ask.open;
                    return Math.round((bid + ask) / 2);
                }
                return 0;
            });
            
            // Create background colors for significant movements
            const pointBackgroundColors = prices.map((price, index) => {
                if (index === 0) return '#10b981';
                
                const movement = movements[index - 1]; // movements array is offset by 1
                if (movement && movement.type === 'spike') return '#22c55e';
                if (movement && movement.type === 'drop') return '#ef4444';
                return '#10b981';
            });
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Price (¬¢)',
                        data: prices,
                        borderColor: '#10b981',
                        backgroundColor: pointBackgroundColors,
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 6,
                        pointBorderWidth: 2,
                        pointBorderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${ticker} - Price Movement Analysis`,
                            color: '#f1f5f9'
                        },
                        legend: {
                            labels: { color: '#f1f5f9' }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' }
                        },
                        y: {
                            grid: { color: '#334155' },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return value + '¬¢';
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>