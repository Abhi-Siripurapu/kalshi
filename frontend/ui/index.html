<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèõÔ∏è Kalshi Terminal - Simple</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #0f172a;
            color: #f1f5f9;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-bottom: 2px solid #334155;
        }
        
        .title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .status {
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr 400px;
            gap: 20px;
        }
        
        .analytics-section {
            display: grid;
            grid-template-rows: auto auto 1fr;
            gap: 20px;
        }
        
        .section {
            background-color: #1e293b;
            border-radius: 8px;
            padding: 20px;
        }
        
        .section-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #e2e8f0;
            border-bottom: 1px solid #334155;
            padding-bottom: 10px;
        }
        
        .market-item {
            background-color: #334155;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .market-item:hover {
            background-color: #475569;
        }
        
        .market-item.selected {
            background-color: #4f46e5;
        }
        
        .market-ticker {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 5px;
        }
        
        .market-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            line-height: 1.3;
        }
        
        .market-prices {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
        }
        
        .price-yes {
            color: #10b981;
        }
        
        .price-no {
            color: #ef4444;
        }
        
        .orderbook {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .orderbook-side {
            background-color: #0f172a;
            border-radius: 6px;
            padding: 15px;
        }
        
        .orderbook-header {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #334155;
        }
        
        .yes-header {
            color: #10b981;
        }
        
        .no-header {
            color: #ef4444;
        }
        
        .order-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 0.8rem;
        }
        
        .loading {
            text-align: center;
            color: #64748b;
            font-style: italic;
        }
        
        .error {
            color: #ef4444;
            text-align: center;
            padding: 20px;
        }
        
        .refresh-btn {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            margin-left: 10px;
        }
        
        .refresh-btn:hover {
            background-color: #4338ca;
        }
        
        .filter-btn {
            background-color: #374151;
            color: #d1d5db;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            transition: background-color 0.2s;
        }
        
        .filter-btn:hover {
            background-color: #4b5563;
        }
        
        .filter-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        
        .alert {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.85rem;
        }
        
        .alert.spike {
            background: rgba(34, 197, 94, 0.2);
            border-left: 4px solid #22c55e;
            color: #22c55e;
        }
        
        .alert.drop {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid #ef4444;
            color: #ef4444;
        }
        
        .alert.momentum {
            background: rgba(245, 158, 11, 0.2);
            border-left: 4px solid #f59e0b;
            color: #f59e0b;
        }
        
        .heatmap-cell {
            display: inline-block;
            width: 30px;
            height: 20px;
            margin: 1px;
            border-radius: 2px;
            text-align: center;
            font-size: 0.7rem;
            line-height: 20px;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">üèõÔ∏è Kalshi Terminal</div>
            <div class="status" id="status">
                Loading... 
                <button class="refresh-btn" onclick="loadData()">Refresh</button>
                <button class="refresh-btn" onclick="testMarketSelection()" style="margin-left: 10px;">Test Analytics</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="section">
                <div class="section-title">Markets <span id="market-count">(0)</span></div>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="market-search" placeholder="Search markets..." 
                           style="width: 100%; padding: 8px; background: #0f172a; border: 1px solid #334155; color: #f1f5f9; border-radius: 4px; font-family: inherit; font-size: 0.9rem;">
                    <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="politics">Politics</button>
                        <button class="filter-btn" data-filter="sports">Sports</button>
                        <button class="filter-btn" data-filter="crypto">Crypto</button>
                        <button class="filter-btn" data-filter="weather">Weather</button>
                    </div>
                </div>
                <div id="markets-list" class="loading">
                    Loading markets...
                </div>
            </div>
            
            <div class="analytics-section">
                <div class="section">
                    <div class="section-title">üìä Price & Volume Analytics</div>
                    <div id="chart-container" style="height: 350px; position: relative;">
                        <canvas id="price-chart"></canvas>
                        <div id="chart-loading" class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                            Select a market to view chart
                        </div>
                        <!-- Real-time price overlays -->
                        <div id="price-overlays" style="position: absolute; top: 10px; right: 10px; display: none;">
                            <div id="bid-info" style="background: rgba(16, 185, 129, 0.9); color: white; padding: 4px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 0.8rem; font-weight: bold;">
                                BID: --
                            </div>
                            <div id="ask-info" style="background: rgba(239, 68, 68, 0.9); color: white; padding: 4px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 0.8rem; font-weight: bold;">
                                ASK: --
                            </div>
                            <div id="spread-info" style="background: rgba(99, 102, 241, 0.9); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">
                                SPREAD: --
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="section-title">üö® Movement Alerts</div>
                    <div id="price-alerts" style="max-height: 200px; overflow-y: auto;">
                        <div class="loading">Select a market to view alerts</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="section-title">üî• Volume Profile</div>
                    <div id="volume-profile-container" style="height: 250px; position: relative;">
                        <canvas id="volume-profile-chart"></canvas>
                        <div id="profile-loading" class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                            Select a market to view volume profile
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">üìã Order Book & Liquidity</div>
                <div id="market-detail">
                    <div class="loading">Select a market to view orderbook</div>
                </div>
                
                <div class="section-title" style="margin-top: 20px;">üå°Ô∏è Liquidity Heatmap</div>
                <div id="liquidity-heatmap" style="margin-top: 10px;">
                    <div class="loading">Select a market to view liquidity heatmap</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        const WS_URL = 'ws://localhost:8001/ws';
        let markets = [];
        let filteredMarkets = [];
        let selectedMarket = null;
        let websocket = null;
        let priceChart = null;
        let volumeProfileChart = null;
        let currentFilter = 'all';
        let currentSearch = '';
        
        // Load API status
        async function loadStatus() {
            try {
                const response = await fetch(`${API_BASE}/`);
                const data = await response.json();
                
                const statusEl = document.getElementById('status');
                const statusText = data.kalshi_connected ? 'üîó Live Data' : 'üìã Mock Mode';
                statusEl.innerHTML = `${statusText} | v${data.version} <button class="refresh-btn" onclick="loadData()">Refresh</button>`;
            } catch (err) {
                const statusEl = document.getElementById('status');
                statusEl.innerHTML = '‚ùå API Disconnected <button class="refresh-btn" onclick="loadData()">Refresh</button>';
            }
        }
        
        // Load markets
        async function loadMarkets() {
            try {
                const response = await fetch(`${API_BASE}/markets?limit=200`);
                const data = await response.json();
                const rawMarkets = data.markets || [];
                
                if (rawMarkets.length === 0) {
                    const listEl = document.getElementById('markets-list');
                    listEl.innerHTML = '<div class="error">No markets found</div>';
                    return;
                }
                
                // Process and filter markets
                markets = processMarkets(rawMarkets);
                console.log(`üìä Processed ${rawMarkets.length} raw markets into ${markets.length} tradeable markets`);
                
                // Initialize filtered markets and display
                filteredMarkets = [...markets];
                filterMarkets();
                
                // Auto-select first market
                if (!selectedMarket && filteredMarkets.length > 0) {
                    console.log('üéØ Auto-selecting first market:', filteredMarkets[0].ticker);
                    selectMarket(filteredMarkets[0].ticker);
                }
                
            } catch (err) {
                const listEl = document.getElementById('markets-list');
                listEl.innerHTML = '<div class="error">Failed to load markets</div>';
                console.error('Error loading markets:', err);
            }
        }
        
        // Process raw markets into tradeable display format
        function processMarkets(rawMarkets) {
            const eventGroups = {};
            const meaningfulBinaryMarkets = [];
            
            // First pass: Group all markets by event_ticker and analyze patterns
            rawMarkets.forEach(market => {
                const eventTicker = market.event_ticker || extractEventTicker(market.ticker);
                
                if (!eventGroups[eventTicker]) {
                    eventGroups[eventTicker] = {
                        event_ticker: eventTicker,
                        markets: [],
                        total_volume: 0,
                        max_individual_volume: 0
                    };
                }
                
                eventGroups[eventTicker].markets.push(market);
                eventGroups[eventTicker].total_volume += (market.volume_24h || 0);
                eventGroups[eventTicker].max_individual_volume = Math.max(
                    eventGroups[eventTicker].max_individual_volume, 
                    market.volume_24h || 0
                );
            });
            
            // Second pass: Determine if event group should be treated as multi-outcome or individual markets
            Object.values(eventGroups).forEach(group => {
                const isActualMultiOutcome = determineIfMultiOutcome(group);
                
                if (isActualMultiOutcome && group.markets.length > 1) {
                    // Create a single multi-outcome display entry
                    const baseMarket = group.markets[0];
                    const multiOutcomeDisplay = {
                        ticker: group.event_ticker,
                        title: extractBaseTitle(baseMarket.title),
                        subtitle: `${group.markets.length} outcomes available`,
                        yes_bid: 0,
                        yes_ask: 0,
                        no_bid: 0,
                        no_ask: 0,
                        volume_24h: group.total_volume,
                        is_multi_outcome: true,
                        outcome_count: group.markets.length,
                        outcomes: group.markets.map(m => ({
                            ticker: m.ticker,
                            title: m.title,
                            yes_bid: m.yes_bid || 0,
                            yes_ask: m.yes_ask || 0,
                            volume_24h: m.volume_24h || 0
                        })).sort((a, b) => (b.volume_24h || 0) - (a.volume_24h || 0))
                    };
                    meaningfulBinaryMarkets.push(multiOutcomeDisplay);
                } else {
                    // Add individual markets that have meaningful activity
                    group.markets.forEach(market => {
                        if (isMeaningfulBinaryMarket(market)) {
                            meaningfulBinaryMarkets.push(market);
                        }
                    });
                }
            });
            
            // Sort by volume descending
            meaningfulBinaryMarkets.sort((a, b) => (b.volume_24h || 0) - (a.volume_24h || 0));
            
            return meaningfulBinaryMarkets;
        }
        
        // Extract event ticker from market ticker (handle different naming patterns)
        function extractEventTicker(ticker) {
            // Handle patterns like PRES-2024, ARTST24-WINNER, etc.
            const parts = ticker.split('-');
            if (parts.length >= 2) {
                // For patterns like ARTST24-WINNER-TAYLOR, return ARTST24-WINNER
                // For patterns like PRES-2024-BIDEN, return PRES-2024
                return parts.slice(0, -1).join('-');
            }
            return ticker;
        }
        
        // Extract base title (remove outcome-specific endings)
        function extractBaseTitle(title) {
            // Remove common outcome patterns
            return title
                .replace(/\s+will\s+win\?.*$/i, ' winner?')
                .replace(/\s+will\s+be\s+.*$/i, ' outcome?')
                .replace(/\?\s*.*$/, '?')
                .trim();
        }
        
        // Determine if a group should be treated as multi-outcome
        function determineIfMultiOutcome(group) {
            const markets = group.markets;
            
            // Must have multiple markets
            if (markets.length <= 1) return false;
            
            // Check for common multi-outcome patterns
            const hasMultiOutcomePattern = markets.some(market => {
                const ticker = market.ticker.toLowerCase();
                const title = market.title.toLowerCase();
                
                return ticker.includes('winner') || 
                       ticker.includes('mvp') || 
                       ticker.includes('artist') ||
                       title.includes('who will') ||
                       title.includes('which ') ||
                       title.includes('winner') ||
                       title.includes('champion');
            });
            
            // Check if most markets in group have low individual liquidity
            const lowLiquidityCount = markets.filter(m => 
                (m.yes_bid || 0) < 5 && (m.yes_ask || 0) > 95 && (m.volume_24h || 0) < 100
            ).length;
            
            const hasLowIndividualLiquidity = lowLiquidityCount > (markets.length * 0.7);
            
            // It's multi-outcome if it has the pattern AND most markets have low liquidity
            return hasMultiOutcomePattern && hasLowIndividualLiquidity;
        }
        
        // Check if a market is meaningful as an individual binary market
        function isMeaningfulBinaryMarket(market) {
            const yes_bid = market.yes_bid || 0;
            const yes_ask = market.yes_ask || 0;
            const volume = market.volume_24h || 0;
            
            // Market is meaningful if it has real pricing activity or volume
            const hasRealPricing = (yes_bid >= 5 && yes_ask <= 95) || 
                                  (yes_bid > 0 && yes_ask < 100 && Math.abs(yes_ask - yes_bid) < 50);
            const hasVolume = volume > 50;
            
            return hasRealPricing || hasVolume;
        }
        
        // Filter and search markets
        function filterMarkets() {
            const searchTerm = currentSearch.toLowerCase();
            
            filteredMarkets = markets.filter(market => {
                // Search filter
                const matchesSearch = market.title.toLowerCase().includes(searchTerm) || 
                                    market.ticker.toLowerCase().includes(searchTerm);
                
                // Category filter
                let matchesCategory = true;
                if (currentFilter !== 'all') {
                    const ticker = market.ticker.toLowerCase();
                    const title = market.title.toLowerCase();
                    
                    switch (currentFilter) {
                        case 'politics':
                            matchesCategory = ticker.includes('potus') || ticker.includes('election') || ticker.includes('president') ||
                                            title.includes('election') || title.includes('president') || title.includes('political');
                            break;
                        case 'sports':
                            matchesCategory = ticker.includes('nfl') || ticker.includes('mlb') || ticker.includes('nba') ||
                                            ticker.includes('pga') || ticker.includes('ufc') || ticker.includes('match') ||
                                            title.includes('sport') || title.includes('game') || title.includes('championship');
                            break;
                        case 'crypto':
                            matchesCategory = ticker.includes('btc') || ticker.includes('eth') || ticker.includes('crypto') ||
                                            title.includes('bitcoin') || title.includes('ethereum') || title.includes('crypto');
                            break;
                        case 'weather':
                            matchesCategory = ticker.includes('weather') || ticker.includes('temp') || ticker.includes('high') ||
                                            title.includes('temperature') || title.includes('weather') || title.includes('snow');
                            break;
                    }
                }
                
                return matchesSearch && matchesCategory;
            });
            
            displayFilteredMarkets();
        }
        
        // Display filtered markets
        function displayFilteredMarkets() {
            const countEl = document.getElementById('market-count');
            countEl.textContent = `(${filteredMarkets.length})`;
            
            const listEl = document.getElementById('markets-list');
            
            if (filteredMarkets.length === 0) {
                listEl.innerHTML = '<div class="error">No markets match your criteria</div>';
                return;
            }
            
            listEl.innerHTML = filteredMarkets.map(market => {
                if (market.is_multi_outcome) {
                    return `
                        <div class="market-item ${selectedMarket === market.ticker ? 'selected' : ''}" onclick="selectMarket('${market.ticker}')">
                            <div class="market-ticker">${market.ticker}</div>
                            <div class="market-title">${market.title}</div>
                            <div class="market-subtitle" style="font-size: 0.75rem; color: #f59e0b; margin: 2px 0;">
                                üìä ${market.outcome_count} outcomes ‚Ä¢ Multi-choice market
                            </div>
                            <div class="market-prices">
                                <span style="color: #94a3b8;">Volume: ${(market.volume_24h || 0).toLocaleString()}</span>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="market-item ${selectedMarket === market.ticker ? 'selected' : ''}" onclick="selectMarket('${market.ticker}')">
                            <div class="market-ticker">${market.ticker}</div>
                            <div class="market-title">${market.title}</div>
                            <div class="market-prices">
                                <span class="price-yes">YES: ${formatPrice(market.yes_bid || 0)} / ${formatPrice(market.yes_ask || 0)}</span>
                                <span class="price-no">NO: ${formatPrice(market.no_bid || 0)} / ${formatPrice(market.no_ask || 0)}</span>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        // Select a market
        async function selectMarket(ticker) {
            console.log(`üéØ Selecting market: ${ticker}`);
            selectedMarket = ticker;
            
            // Update visual selection
            document.querySelectorAll('.market-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            const selectedItem = Array.from(document.querySelectorAll('.market-item')).find(item => 
                item.querySelector('.market-ticker').textContent === ticker
            );
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }
            
            // Subscribe to real-time orderbook for this market
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const subscription = {
                    type: 'subscribe',
                    channels: ['orderbook'],
                    market_ticker: ticker
                };
                websocket.send(JSON.stringify(subscription));
                console.log(`üìã Subscribed to orderbook for ${ticker}`);
            }
            
            try {
                // Load market detail and chart
                console.log(`üìä Loading market detail for ${ticker}...`);
                await loadMarketDetail(ticker);
                console.log(`üìà Loading price chart for ${ticker}...`);
                await loadPriceChart(ticker);
                console.log(`‚úÖ Market ${ticker} loaded successfully`);
            } catch (error) {
                console.error(`‚ùå Error loading market ${ticker}:`, error);
            }
        }
        
        // Load market detail and orderbook
        async function loadMarketDetail(ticker) {
            const detailEl = document.getElementById('market-detail');
            detailEl.innerHTML = '<div class="loading">Loading market detail...</div>';
            
            try {
                const market = markets.find(m => m.ticker === ticker);
                
                // Handle multi-outcome markets differently
                if (market && market.is_multi_outcome) {
                    displayMultiOutcomeMarket(market, detailEl);
                    updateLiquidityHeatmapForMultiOutcome(market);
                    return;
                }
                
                // Load orderbook for binary markets
                const orderbookResponse = await fetch(`${API_BASE}/market/${ticker}/orderbook`);
                const orderbookData = await orderbookResponse.json();
                const orderbook = orderbookData.orderbook;
                
                detailEl.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;">${ticker}</div>
                        <div style="font-weight: bold;">${market ? market.title : 'Market Details'}</div>
                    </div>
                    
                    <div class="section-title">Order Book</div>
                    <div class="orderbook">
                        <div class="orderbook-side">
                            <div class="orderbook-header yes-header">YES</div>
                            ${formatOrderbookSide(orderbook.yes)}
                        </div>
                        <div class="orderbook-side">
                            <div class="orderbook-header no-header">NO</div>
                            ${formatOrderbookSide(orderbook.no)}
                        </div>
                    </div>
                `;
                
                // Update heatmap for binary markets
                updateLiquidityHeatmap(orderbook);
                
            } catch (err) {
                detailEl.innerHTML = '<div class="error">Failed to load market detail</div>';
                console.error('Error loading market detail:', err);
            }
        }
        
        // Display multi-outcome market with individual outcomes
        function displayMultiOutcomeMarket(market, detailEl) {
            const outcomes = market.outcomes || [];
            const totalVolume = market.volume_24h || 0;
            
            // Sort outcomes by volume and price activity
            const sortedOutcomes = outcomes.sort((a, b) => {
                const aActivity = (a.volume_24h || 0) + (a.yes_bid || 0);
                const bActivity = (b.volume_24h || 0) + (b.yes_bid || 0);
                return bActivity - aActivity;
            });
            
            const outcomesList = sortedOutcomes.map(outcome => {
                const hasActivity = (outcome.yes_bid || 0) > 5 || (outcome.volume_24h || 0) > 10;
                const probability = outcome.yes_bid > 0 ? `${((outcome.yes_bid / 100) * 100).toFixed(1)}%` : 'N/A';
                
                return `
                    <div class="outcome-item" style="
                        background-color: ${hasActivity ? '#334155' : '#1e293b'}; 
                        border-radius: 6px; 
                        padding: 12px; 
                        margin-bottom: 8px;
                        border-left: 3px solid ${hasActivity ? '#10b981' : '#64748b'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 2px;">${outcome.ticker}</div>
                                <div style="font-size: 0.9rem; font-weight: ${hasActivity ? 'bold' : 'normal'}; 
                                           color: ${hasActivity ? '#f1f5f9' : '#94a3b8'};">
                                    ${outcome.title}
                                </div>
                            </div>
                            <div style="text-align: right; margin-left: 10px;">
                                <div style="font-size: 0.9rem; font-weight: bold; color: ${hasActivity ? '#10b981' : '#64748b'};">
                                    ${probability}
                                </div>
                                <div style="font-size: 0.7rem; color: #64748b;">
                                    ${hasActivity ? `${outcome.yes_bid || 0}¬¢ bid` : 'No activity'}
                                </div>
                                ${(outcome.volume_24h || 0) > 0 ? `
                                    <div style="font-size: 0.7rem; color: #94a3b8;">
                                        Vol: ${(outcome.volume_24h || 0).toLocaleString()}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            detailEl.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;">${market.ticker}</div>
                    <div style="font-weight: bold; line-height: 1.3;">${market.title}</div>
                    <div style="font-size: 0.8rem; color: #f59e0b; margin-top: 5px;">
                        üìä ${market.outcome_count} outcomes ‚Ä¢ Total volume: ${totalVolume.toLocaleString()}
                    </div>
                </div>
                
                <div class="section-title">Individual Outcomes</div>
                <div style="max-height: 400px; overflow-y: auto;">
                    ${outcomesList}
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background-color: #0f172a; border-radius: 6px; text-align: center;">
                    <div style="color: #94a3b8; font-size: 0.8rem; line-height: 1.4;">
                        üí° <strong>Multi-outcome market:</strong> Each outcome represents a different possible result.<br>
                        Only one outcome can be correct. Probabilities may not sum to 100% due to market inefficiencies.
                    </div>
                </div>
            `;
        }
        
        // Load price chart for selected market
        async function loadPriceChart(ticker) {
            console.log(`üìä loadPriceChart called for ${ticker}`);
            const chartLoading = document.getElementById('chart-loading');
            const canvas = document.getElementById('price-chart');
            
            if (!chartLoading) {
                console.error('‚ùå chart-loading element not found');
                return;
            }
            
            try {
                chartLoading.style.display = 'block';
                chartLoading.textContent = 'Loading chart...';
                
                // Fetch candlestick data
                console.log(`üìä Fetching candlestick data for ${ticker}...`);
                const response = await fetch(`${API_BASE}/market/${ticker}/candlesticks?period_interval=60&start_days_ago=7`);
                const data = await response.json();
                
                console.log('üìä Candlestick data received:', data);
                
                if (data.candlesticks && data.candlesticks.length > 0) {
                    console.log(`üìä Creating chart with ${data.candlesticks.length} candlesticks`);
                    
                    // Get current market data for overlays
                    const market = markets.find(m => m.ticker === ticker);
                    console.log('üìä Market data for overlays:', market);
                    
                    try {
                        console.log('üìä Creating price chart...');
                        createPriceChart(data.candlesticks, ticker, market);
                        console.log('‚úÖ Price chart created');
                    } catch (err) {
                        console.error('‚ùå Error creating price chart:', err);
                    }
                    
                    try {
                        console.log('üìä Updating price overlays...');
                        updatePriceOverlays(market);
                        console.log('‚úÖ Price overlays updated');
                    } catch (err) {
                        console.error('‚ùå Error updating price overlays:', err);
                    }
                    
                    // Load additional analytics with error handling
                    try {
                        console.log('üìä Loading price alerts...');
                        loadPriceAlerts(data.candlesticks, ticker);
                        console.log('‚úÖ Price alerts loaded');
                    } catch (err) {
                        console.error('‚ùå Error loading price alerts:', err);
                    }
                    
                    try {
                        console.log('üìä Loading volume profile...');
                        loadVolumeProfile(data.candlesticks, ticker);
                        console.log('‚úÖ Volume profile loaded');
                    } catch (err) {
                        console.error('‚ùå Error loading volume profile:', err);
                    }
                    
                    chartLoading.style.display = 'none';
                    console.log('üìä Chart loading completed');
                } else {
                    console.log('üìä No candlestick data available');
                    chartLoading.textContent = 'No chart data available';
                }
                
            } catch (err) {
                console.error('‚ùå Error loading price chart:', err);
                chartLoading.textContent = 'Failed to load chart';
            }
        }
        
        // Create price chart using Chart.js
        function createPriceChart(candlesticks, ticker, market) {
            console.log('üìä createPriceChart called with:', { candlesticks, ticker, market });
            const ctx = document.getElementById('price-chart').getContext('2d');
            
            // Destroy existing chart if exists
            if (priceChart) {
                priceChart.destroy();
            }
            
            // Prepare data for chart - handle both mock and real Kalshi data formats
            const labels = candlesticks.map((candle, index) => {
                const timestamp = candle.end_period_ts || candle.ts;
                
                if (timestamp) {
                    // Handle both seconds and milliseconds timestamps
                    const dateMs = timestamp > 1000000000000 ? timestamp : timestamp * 1000;
                    const date = new Date(dateMs);
                    
                    // Check if date is valid (allow reasonable range including future dates for Kalshi data)
                    if (!isNaN(date.getTime()) && date.getFullYear() >= 2020 && date.getFullYear() <= 2030) {
                        // Show both date and time for better granularity
                        const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                        const dateStr = date.toLocaleDateString([], {month: 'short', day: 'numeric'});
                        return `${dateStr} ${timeStr}`;
                    }
                }
                
                // Improved fallback with actual time spacing
                const now = new Date();
                const hoursAgo = (candlesticks.length - index - 1);
                const fallbackTime = new Date(now.getTime() - (hoursAgo * 60 * 60 * 1000));
                const timeStr = fallbackTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                const dateStr = fallbackTime.toLocaleDateString([], {month: 'short', day: 'numeric'});
                return `${dateStr} ${timeStr}`;
            });
            
            // Extract price data - prioritize actual traded prices, fall back to mid-price of bid/ask
            const prices = candlesticks.map(candle => {
                if (candle.close !== undefined) {
                    // Mock data format
                    return candle.close;
                } else if (candle.price && candle.price.close !== null) {
                    // Real Kalshi data - actual trade price
                    return candle.price.close;
                } else if (candle.yes_bid && candle.yes_ask) {
                    // Real Kalshi data - mid-price between bid and ask
                    const bid = candle.yes_bid.close || candle.yes_bid.open;
                    const ask = candle.yes_ask.close || candle.yes_ask.open;
                    return Math.round((bid + ask) / 2);
                }
                return 0;
            });
            
            const volumes = candlesticks.map(candle => candle.volume || 0);
            
            // Calculate VWAP (Volume Weighted Average Price)
            const vwapData = calculateVWAP(candlesticks);
            
            console.log('üìä Chart data prepared:', { labels, prices, volumes, vwap: vwapData });
            
            // Calculate actual time range for title
            const firstLabel = labels[0] || 'Unknown';
            const lastLabel = labels[labels.length - 1] || 'Unknown';
            const chartTitle = `${ticker} - Price & Volume (${candlesticks.length} periods)`;
            
            // Prepare chart datasets
            const datasets = [{
                label: 'Price (¬¢)',
                data: prices,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                yAxisID: 'y'
            }, {
                label: 'VWAP (¬¢)',
                data: vwapData,
                borderColor: '#f59e0b',
                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                yAxisID: 'y'
            }, {
                label: 'Volume',
                data: volumes,
                type: 'bar',
                backgroundColor: 'rgba(99, 102, 241, 0.3)',
                borderColor: 'rgba(99, 102, 241, 0.8)',
                borderWidth: 1,
                yAxisID: 'y1'
            }];
            
            // Add bid/ask reference lines if market data available
            if (market && (market.yes_bid || market.yes_ask)) {
                if (market.yes_bid > 0) {
                    datasets.push({
                        label: 'Current Bid',
                        data: Array(labels.length).fill(market.yes_bid),
                        borderColor: 'rgba(16, 185, 129, 0.8)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y'
                    });
                }
                
                if (market.yes_ask > 0) {
                    datasets.push({
                        label: 'Current Ask',
                        data: Array(labels.length).fill(market.yes_ask),
                        borderColor: 'rgba(239, 68, 68, 0.8)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y'
                    });
                }
            }
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            color: '#f1f5f9'
                        },
                        legend: {
                            labels: {
                                color: '#f1f5f9'
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#334155'
                            },
                            ticks: {
                                color: '#94a3b8',
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: '#334155'
                            },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return value + '¬¢';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Price (¬¢)',
                                color: '#94a3b8'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#94a3b8'
                            },
                            title: {
                                display: true,
                                text: 'Volume',
                                color: '#94a3b8'
                            }
                        }
                    }
                }
            });
        }
        
        // Calculate VWAP (Volume Weighted Average Price)
        function calculateVWAP(candlesticks) {
            let cumulativeVolumePrice = 0;
            let cumulativeVolume = 0;
            const vwapData = [];
            
            for (let i = 0; i < candlesticks.length; i++) {
                const candle = candlesticks[i];
                
                // Get typical price (average of high, low, close)
                let typicalPrice;
                if (candle.price && candle.price.high !== null) {
                    // Real Kalshi data
                    const high = candle.price.high || candle.price.close;
                    const low = candle.price.low || candle.price.close;
                    const close = candle.price.close;
                    typicalPrice = (high + low + close) / 3;
                } else if (candle.yes_bid && candle.yes_ask) {
                    // Fallback to mid-price
                    const bid = candle.yes_bid.close || candle.yes_bid.open;
                    const ask = candle.yes_ask.close || candle.yes_ask.open;
                    typicalPrice = (bid + ask) / 2;
                } else {
                    typicalPrice = candle.close || 50; // Mock data fallback
                }
                
                const volume = candle.volume || 0;
                
                // Accumulate volume * price and volume
                cumulativeVolumePrice += typicalPrice * volume;
                cumulativeVolume += volume;
                
                // Calculate VWAP
                const vwap = cumulativeVolume > 0 ? cumulativeVolumePrice / cumulativeVolume : typicalPrice;
                vwapData.push(vwap);
            }
            
            return vwapData;
        }
        
        // Detect price movements and generate alerts
        function detectPriceMovements(candlesticks) {
            const movements = [];
            const alerts = [];
            
            for (let i = 1; i < candlesticks.length; i++) {
                const current = candlesticks[i];
                const previous = candlesticks[i - 1];
                
                // Extract prices
                let currentPrice, previousPrice;
                
                if (current.price && current.price.close !== null) {
                    currentPrice = current.price.close;
                } else if (current.yes_bid && current.yes_ask) {
                    const bid = current.yes_bid.close || current.yes_bid.open;
                    const ask = current.yes_ask.close || current.yes_ask.open;
                    currentPrice = (bid + ask) / 2;
                } else {
                    currentPrice = current.close || 50;
                }
                
                if (previous.price && previous.price.close !== null) {
                    previousPrice = previous.price.close;
                } else if (previous.yes_bid && previous.yes_ask) {
                    const bid = previous.yes_bid.close || previous.yes_bid.open;
                    const ask = previous.yes_ask.close || previous.yes_ask.open;
                    previousPrice = (bid + ask) / 2;
                } else {
                    previousPrice = previous.close || 50;
                }
                
                // Calculate percentage change
                const priceChange = currentPrice - previousPrice;
                const percentChange = previousPrice > 0 ? (priceChange / previousPrice) * 100 : 0;
                
                const movement = {
                    index: i,
                    timestamp: current.end_period_ts || current.ts,
                    previousPrice: previousPrice,
                    currentPrice: currentPrice,
                    priceChange: priceChange,
                    percentChange: percentChange,
                    volume: current.volume || 0,
                    type: percentChange > 2 ? 'spike' : percentChange < -2 ? 'drop' : 'normal'
                };
                
                movements.push(movement);
                
                // Generate alerts for significant movements
                if (Math.abs(percentChange) >= 2) {
                    const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${i}`;
                    alerts.push({
                        type: movement.type,
                        message: `${movement.type === 'spike' ? 'üìà' : 'üìâ'} ${Math.abs(percentChange).toFixed(1)}% ${movement.type === 'spike' ? 'surge' : 'drop'} at ${timestamp}`,
                        details: `${previousPrice.toFixed(1)}¬¢ ‚Üí ${currentPrice.toFixed(1)}¬¢ (Volume: ${movement.volume.toLocaleString()})`
                    });
                }
            }
            
            // Detect momentum (3+ consecutive moves in same direction)
            let consecutiveUps = 0;
            let consecutiveDowns = 0;
            
            for (let i = 0; i < movements.length; i++) {
                const movement = movements[i];
                
                if (movement.priceChange > 0) {
                    consecutiveUps++;
                    consecutiveDowns = 0;
                    
                    if (consecutiveUps >= 3) {
                        const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${movement.index}`;
                        alerts.push({
                            type: 'momentum',
                            message: `üöÄ Bullish momentum detected at ${timestamp}`,
                            details: `${consecutiveUps} consecutive periods of price increases`
                        });
                        consecutiveUps = 0;
                    }
                } else if (movement.priceChange < 0) {
                    consecutiveDowns++;
                    consecutiveUps = 0;
                    
                    if (consecutiveDowns >= 3) {
                        const timestamp = movement.timestamp ? new Date(movement.timestamp * 1000).toLocaleTimeString() : `Period ${movement.index}`;
                        alerts.push({
                            type: 'momentum',
                            message: `üìâ Bearish momentum detected at ${timestamp}`,
                            details: `${consecutiveDowns} consecutive periods of price decreases`
                        });
                        consecutiveDowns = 0;
                    }
                }
            }
            
            return { movements, alerts };
        }
        
        // Calculate volume profile
        function calculateVolumeProfile(candlesticks) {
            const priceBuckets = {};
            let minPrice = Infinity;
            let maxPrice = -Infinity;
            
            candlesticks.forEach(candle => {
                let price, volume;
                
                if (candle.price && candle.price.close !== null) {
                    price = candle.price.close;
                } else if (candle.yes_bid && candle.yes_ask) {
                    const bid = candle.yes_bid.close || candle.yes_bid.open;
                    const ask = candle.yes_ask.close || candle.yes_ask.open;
                    price = Math.round((bid + ask) / 2);
                } else {
                    price = candle.close || 50;
                }
                
                volume = candle.volume || 0;
                const bucketPrice = Math.round(price);
                
                if (!priceBuckets[bucketPrice]) {
                    priceBuckets[bucketPrice] = 0;
                }
                priceBuckets[bucketPrice] += volume;
                
                minPrice = Math.min(minPrice, bucketPrice);
                maxPrice = Math.max(maxPrice, bucketPrice);
            });
            
            const profileData = [];
            for (let price = minPrice; price <= maxPrice; price++) {
                profileData.push({
                    price: price,
                    volume: priceBuckets[price] || 0
                });
            }
            
            const sortedByVolume = [...profileData].sort((a, b) => b.volume - a.volume);
            
            return {
                profile: profileData,
                highVolumeNodes: sortedByVolume.slice(0, 3),
                priceRange: { min: minPrice, max: maxPrice }
            };
        }
        
        // Load price alerts
        function loadPriceAlerts(candlesticks, ticker) {
            const alertsContainer = document.getElementById('price-alerts');
            const analysis = detectPriceMovements(candlesticks);
            
            if (analysis.alerts.length > 0) {
                alertsContainer.innerHTML = analysis.alerts.map(alert => `
                    <div class="alert ${alert.type}">
                        <div>${alert.message}</div>
                        <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 4px;">${alert.details}</div>
                    </div>
                `).join('');
            } else {
                alertsContainer.innerHTML = '<div style="text-align: center; color: #64748b; font-style: italic;">No significant movements detected</div>';
            }
        }
        
        // Load volume profile chart
        function loadVolumeProfile(candlesticks, ticker) {
            const ctx = document.getElementById('volume-profile-chart').getContext('2d');
            const profileLoading = document.getElementById('profile-loading');
            
            if (volumeProfileChart) {
                volumeProfileChart.destroy();
            }
            
            const volumeProfile = calculateVolumeProfile(candlesticks);
            const profileData = volumeProfile.profile.filter(p => p.volume > 0);
            
            if (profileData.length === 0) {
                profileLoading.textContent = 'No volume data available';
                return;
            }
            
            const labels = profileData.map(p => p.price + '¬¢');
            const volumes = profileData.map(p => p.volume);
            
            // Color high volume nodes
            const backgroundColors = profileData.map(p => {
                const isHighVolume = volumeProfile.highVolumeNodes.some(n => n.price === p.price);
                return isHighVolume ? 'rgba(245, 158, 11, 0.8)' : 'rgba(99, 102, 241, 0.6)';
            });
            
            volumeProfileChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Volume at Price',
                        data: volumes,
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(99, 102, 241, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Volume Profile - ${ticker}`,
                            color: '#f1f5f9'
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' },
                            title: {
                                display: true,
                                text: 'Volume',
                                color: '#94a3b8'
                            }
                        },
                        y: {
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' },
                            title: {
                                display: true,
                                text: 'Price Level',
                                color: '#94a3b8'
                            }
                        }
                    }
                }
            });
            
            profileLoading.style.display = 'none';
        }
        
        // Create liquidity heatmap for orderbook
        function updateLiquidityHeatmap(orderbookData) {
            const heatmapContainer = document.getElementById('liquidity-heatmap');
            
            const yesOrders = orderbookData.yes || [];
            const noOrders = orderbookData.no || [];
            
            if (yesOrders.length === 0 && noOrders.length === 0) {
                heatmapContainer.innerHTML = '<div style="text-align: center; color: #64748b; font-style: italic;">No liquidity data available</div>';
                return;
            }
            
            // Combine and analyze all orders
            const allOrders = [
                ...yesOrders.map(order => ({ price: order[0], size: order[1], side: 'yes' })),
                ...noOrders.map(order => ({ price: order[0], size: order[1], side: 'no' }))
            ];
            
            // Calculate liquidity metrics
            const totalVolume = allOrders.reduce((sum, order) => sum + order.size, 0);
            const maxOrderSize = Math.max(...allOrders.map(order => order.size));
            
            // Create price buckets (5-cent ranges)
            const priceBuckets = {};
            allOrders.forEach(order => {
                const bucket = Math.floor(order.price / 5) * 5; // 5-cent buckets
                if (!priceBuckets[bucket]) {
                    priceBuckets[bucket] = { yes: 0, no: 0, total: 0 };
                }
                priceBuckets[bucket][order.side] += order.size;
                priceBuckets[bucket].total += order.size;
            });
            
            // Sort buckets by price
            const sortedBuckets = Object.keys(priceBuckets)
                .map(price => parseInt(price))
                .sort((a, b) => b - a); // Highest price first
            
            // Generate heatmap HTML
            let heatmapHTML = '<div style="margin-bottom: 10px; font-size: 0.8rem; color: #94a3b8;">Liquidity Intensity by Price Range</div>';
            
            if (sortedBuckets.length > 0) {
                heatmapHTML += '<div style="display: flex; flex-wrap: wrap; gap: 2px;">';
                
                sortedBuckets.forEach(bucketPrice => {
                    const bucket = priceBuckets[bucketPrice];
                    const intensity = bucket.total / maxOrderSize;
                    
                    // Color based on intensity and side dominance
                    let backgroundColor;
                    if (bucket.yes > bucket.no) {
                        // YES side dominant
                        backgroundColor = `rgba(16, 185, 129, ${0.3 + intensity * 0.7})`;
                    } else if (bucket.no > bucket.yes) {
                        // NO side dominant
                        backgroundColor = `rgba(239, 68, 68, ${0.3 + intensity * 0.7})`;
                    } else {
                        // Balanced
                        backgroundColor = `rgba(99, 102, 241, ${0.3 + intensity * 0.7})`;
                    }
                    
                    const cellTitle = `${bucketPrice}-${bucketPrice + 4}¬¢: ${bucket.total.toLocaleString()} shares (YES: ${bucket.yes}, NO: ${bucket.no})`;
                    
                    heatmapHTML += `
                        <div class="heatmap-cell" 
                             style="background-color: ${backgroundColor};" 
                             title="${cellTitle}">
                            ${bucketPrice}¬¢
                        </div>
                    `;
                });
                
                heatmapHTML += '</div>';
                
                // Add legend
                heatmapHTML += `
                    <div style="margin-top: 10px; font-size: 0.7rem; color: #64748b;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                            <div style="width: 15px; height: 15px; background: rgba(16, 185, 129, 0.8); border-radius: 2px;"></div>
                            <span>YES dominant</span>
                            <div style="width: 15px; height: 15px; background: rgba(239, 68, 68, 0.8); border-radius: 2px;"></div>
                            <span>NO dominant</span>
                            <div style="width: 15px; height: 15px; background: rgba(99, 102, 241, 0.8); border-radius: 2px;"></div>
                            <span>Balanced</span>
                        </div>
                        <div>Brightness = liquidity intensity ‚Ä¢ Total liquidity: ${totalVolume.toLocaleString()} shares</div>
                    </div>
                `;
            } else {
                heatmapHTML += '<div style="text-align: center; color: #64748b; font-style: italic;">No meaningful liquidity detected</div>';
            }
            
            heatmapContainer.innerHTML = heatmapHTML;
        }
        
        // Create liquidity heatmap for multi-outcome markets
        function updateLiquidityHeatmapForMultiOutcome(market) {
            const heatmapContainer = document.getElementById('liquidity-heatmap');
            const outcomes = market.outcomes || [];
            
            if (outcomes.length === 0) {
                heatmapContainer.innerHTML = '<div style="text-align: center; color: #64748b; font-style: italic;">No outcome data available</div>';
                return;
            }
            
            // Analyze outcome probabilities and activity
            const activeOutcomes = outcomes.filter(outcome => 
                (outcome.yes_bid || 0) > 5 || (outcome.volume_24h || 0) > 10
            );
            
            if (activeOutcomes.length === 0) {
                heatmapContainer.innerHTML = `
                    <div style="margin-bottom: 10px; font-size: 0.8rem; color: #94a3b8;">Multi-Outcome Market Activity</div>
                    <div style="text-align: center; color: #64748b; font-style: italic; padding: 20px;">
                        <div style="margin-bottom: 10px;">üìä ${outcomes.length} outcomes available</div>
                        <div>Currently low market activity across all outcomes</div>
                    </div>
                `;
                return;
            }
            
            // Sort outcomes by activity (bid price + volume)
            const sortedOutcomes = activeOutcomes.sort((a, b) => {
                const aActivity = (a.yes_bid || 0) + (a.volume_24h || 0) * 0.01;
                const bActivity = (b.yes_bid || 0) + (b.volume_24h || 0) * 0.01;
                return bActivity - aActivity;
            });
            
            const maxActivity = Math.max(...sortedOutcomes.map(o => 
                (o.yes_bid || 0) + (o.volume_24h || 0) * 0.01
            ));
            
            let heatmapHTML = `
                <div style="margin-bottom: 10px; font-size: 0.8rem; color: #94a3b8;">
                    Multi-Outcome Market Activity (${activeOutcomes.length} of ${outcomes.length} active)
                </div>
                <div style="display: flex; flex-direction: column; gap: 3px;">
            `;
            
            sortedOutcomes.forEach(outcome => {
                const activity = (outcome.yes_bid || 0) + (outcome.volume_24h || 0) * 0.01;
                const intensity = maxActivity > 0 ? activity / maxActivity : 0;
                const probability = outcome.yes_bid > 0 ? (outcome.yes_bid / 100 * 100) : 0;
                
                // Color based on probability
                let backgroundColor;
                if (probability > 50) {
                    backgroundColor = `rgba(16, 185, 129, ${0.3 + intensity * 0.7})`;
                } else if (probability > 20) {
                    backgroundColor = `rgba(245, 158, 11, ${0.3 + intensity * 0.7})`;
                } else {
                    backgroundColor = `rgba(239, 68, 68, ${0.3 + intensity * 0.7})`;
                }
                
                const shortTitle = outcome.title.length > 40 ? 
                    outcome.title.substring(0, 37) + '...' : outcome.title;
                
                heatmapHTML += `
                    <div style="
                        background-color: ${backgroundColor};
                        border-radius: 4px;
                        padding: 8px 10px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        border-left: 3px solid ${probability > 50 ? '#10b981' : probability > 20 ? '#f59e0b' : '#ef4444'};
                    " title="${outcome.title} - ${probability.toFixed(1)}% probability">
                        <div style="flex: 1; font-size: 0.8rem; color: #f1f5f9; font-weight: ${intensity > 0.7 ? 'bold' : 'normal'};">
                            ${shortTitle}
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; font-size: 0.7rem;">
                            <span style="color: #f1f5f9; font-weight: bold;">${probability.toFixed(1)}%</span>
                            ${(outcome.volume_24h || 0) > 0 ? `
                                <span style="color: #94a3b8;">Vol: ${(outcome.volume_24h || 0).toLocaleString()}</span>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            heatmapHTML += `
                </div>
                <div style="margin-top: 10px; font-size: 0.7rem; color: #64748b;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <div style="width: 15px; height: 15px; background: rgba(16, 185, 129, 0.8); border-radius: 2px;"></div>
                        <span>High probability (>50%)</span>
                        <div style="width: 15px; height: 15px; background: rgba(245, 158, 11, 0.8); border-radius: 2px;"></div>
                        <span>Medium (20-50%)</span>
                        <div style="width: 15px; height: 15px; background: rgba(239, 68, 68, 0.8); border-radius: 2px;"></div>
                        <span>Low (<20%)</span>
                    </div>
                    <div>Brightness = market activity ‚Ä¢ Total volume: ${market.volume_24h.toLocaleString()} shares</div>
                </div>
            `;
            
            heatmapContainer.innerHTML = heatmapHTML;
        }
        
        // Update price overlays with current bid/ask
        function updatePriceOverlays(market) {
            const overlaysContainer = document.getElementById('price-overlays');
            const bidInfo = document.getElementById('bid-info');
            const askInfo = document.getElementById('ask-info');
            const spreadInfo = document.getElementById('spread-info');
            
            if (!market || (!market.yes_bid && !market.yes_ask)) {
                overlaysContainer.style.display = 'none';
                return;
            }
            
            const bid = market.yes_bid || 0;
            const ask = market.yes_ask || 0;
            const spread = ask - bid;
            const spreadPercent = bid > 0 ? ((spread / bid) * 100).toFixed(1) : 0;
            
            bidInfo.textContent = `BID: ${bid}¬¢`;
            askInfo.textContent = `ASK: ${ask}¬¢`;
            spreadInfo.textContent = `SPREAD: ${spread}¬¢ (${spreadPercent}%)`;
            
            overlaysContainer.style.display = 'block';
        }
        
        // Format orderbook side
        function formatOrderbookSide(orders, side) {
            if (!orders || orders.length === 0) {
                return '<div style="text-align: center; color: #64748b; font-style: italic;">No meaningful orders</div>';
            }
            
            // Filter out extremely low-priced orders (likely market makers at minimum price)
            const meaningfulOrders = orders.filter(order => order[0] >= 5);
            
            if (meaningfulOrders.length === 0) {
                const bestOrder = orders.reduce((max, order) => order[0] > max[0] ? order : max, orders[0]);
                return `
                    <div style="text-align: center; color: #64748b; font-style: italic; margin-bottom: 10px;">Only low-priced orders</div>
                    <div class="order-row" style="color: #64748b;">
                        <span>Best: ${formatPrice(bestOrder[0])}</span>
                        <span>${bestOrder[1].toLocaleString()}</span>
                    </div>
                `;
            }
            
            // Sort orders by price (highest first for bids)
            const sortedOrders = meaningfulOrders.sort((a, b) => b[0] - a[0]);
            
            return `
                <div class="order-row" style="font-weight: bold; color: #94a3b8; border-bottom: 1px solid #334155; margin-bottom: 5px;">
                    <span>Price</span>
                    <span>Size</span>
                </div>
                ${sortedOrders.slice(0, 5).map((order, index) => {
                    const isTop = index === 0;
                    const priceColor = isTop ? (side === 'yes' ? '#10b981' : '#ef4444') : '#f1f5f9';
                    return `
                        <div class="order-row" style="color: ${priceColor}; ${isTop ? 'font-weight: bold;' : ''}">
                            <span>${formatPrice(order[0])}</span>
                            <span>${order[1].toLocaleString()}</span>
                        </div>
                    `;
                }).join('')}
                ${sortedOrders.length > 5 ? `
                    <div style="text-align: center; color: #64748b; font-style: italic; margin-top: 5px; font-size: 0.8rem;">
                        +${sortedOrders.length - 5} more levels
                    </div>
                ` : ''}
            `;
        }
        
        // Format price in cents to dollars
        function formatPrice(cents) {
            return `$${(cents / 100).toFixed(2)}`;
        }
        
        // Load all data
        async function loadData() {
            await loadStatus();
            await loadMarkets();
        }
        
        // Test function for debugging market selection
        async function testMarketSelection() {
            console.log('üß™ Manual test triggered');
            console.log('üìä Markets array length:', markets.length);
            console.log('üìä Filtered markets length:', filteredMarkets.length);
            console.log('üìä Selected market:', selectedMarket);
            
            if (markets.length > 0) {
                const testTicker = markets[0].ticker;
                console.log(`üß™ Testing with ticker: ${testTicker}`);
                await selectMarket(testTicker);
            } else {
                console.log('‚ùå No markets available for testing');
            }
        }
        
        // WebSocket connection
        function connectWebSocket() {
            try {
                websocket = new WebSocket(WS_URL);
                
                websocket.onopen = function(event) {
                    console.log('üîå WebSocket connected');
                    updateStatus('üîó Real-time Connected');
                    
                    // Subscribe to updates
                    const subscription = {
                        type: 'subscribe',
                        channels: ['ticker', 'orderbook', 'trades']
                    };
                    websocket.send(JSON.stringify(subscription));
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        handleWebSocketMessage(message);
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('üîå WebSocket disconnected');
                    updateStatus('üì° Reconnecting...');
                    
                    // Reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
                
                websocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    updateStatus('‚ùå WebSocket Error');
                };
                
            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                updateStatus('‚ùå WebSocket Failed');
            }
        }
        
        function handleWebSocketMessage(message) {
            const type = message.type;
            
            if (type === 'connected') {
                console.log('‚úÖ WebSocket server ready');
                const kalshiConnected = message.data.kalshi_connected;
                const cachedMarkets = message.data.cached_markets;
                updateStatus(`üîó Real Kalshi Data (${cachedMarkets} markets)`);
                
            } else if (type === 'subscribed') {
                console.log('üìã Subscribed to:', message.data.channels);
                
            } else if (type === 'ticker') {
                handleTickerUpdate(message.data);
                
            } else if (type === 'orderbook_snapshot') {
                handleOrderbookUpdate(message.data);
                
            } else if (type === 'orderbook_delta') {
                handleOrderbookUpdate(message.data);
                
            } else if (type === 'trade') {
                handleTradeUpdate(message.data);
                
            } else {
                console.log('üì• Unknown message type:', type, message);
            }
        }
        
        function handleTickerUpdate(data) {
            // Update market in our local array
            const marketIndex = markets.findIndex(m => m.ticker === data.market_ticker);
            if (marketIndex >= 0) {
                markets[marketIndex].yes_bid = data.bid;
                markets[marketIndex].yes_ask = data.ask;
                markets[marketIndex].last_price = data.last_price;
                markets[marketIndex].volume_24h = data.volume_24h;
                
                // Refresh the markets display
                refreshMarketsDisplay();
            }
        }
        
        function handleOrderbookUpdate(data) {
            // If this is for the selected market, update the orderbook display
            if (selectedMarket === data.market_ticker) {
                updateOrderbookDisplay(data);
            }
        }
        
        function handleTradeUpdate(data) {
            console.log('üí∞ Trade:', data);
            // Could add trade feed display here
        }
        
        function updateStatus(statusText) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.innerHTML = `${statusText} <button class="refresh-btn" onclick="loadData()">Refresh</button>`;
            }
        }
        
        function refreshMarketsDisplay() {
            // Re-render the markets list with updated data
            const listEl = document.getElementById('markets-list');
            if (!listEl || markets.length === 0) return;
            
            listEl.innerHTML = markets.map(market => `
                <div class="market-item ${selectedMarket === market.ticker ? 'selected' : ''}" onclick="selectMarket('${market.ticker}')">
                    <div class="market-ticker">${market.ticker}</div>
                    <div class="market-title">${market.title}</div>
                    <div class="market-prices">
                        <span class="price-yes">YES: ${formatPrice(market.yes_bid || 0)} / ${formatPrice(market.yes_ask || 0)}</span>
                        <span class="price-no">NO: ${formatPrice(market.no_bid || 0)} / ${formatPrice(market.no_ask || 0)}</span>
                    </div>
                </div>
            `).join('');
        }
        
        function updateOrderbookDisplay(data) {
            const detailEl = document.getElementById('market-detail');
            if (!detailEl) return;
            
            const market = markets.find(m => m.ticker === data.market_ticker);
            const timestamp = data.ts ? new Date(data.ts * 1000).toLocaleTimeString() : 'Unknown';
            
            // Update liquidity heatmap
            updateLiquidityHeatmap(data);
            
            // Detect multi-outcome markets (when orderbooks are empty or very limited)
            const isMultiOutcome = detectMultiOutcomeMarket(data, market);
            
            if (isMultiOutcome) {
                detailEl.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;">${data.market_ticker}</div>
                        <div style="font-weight: bold; line-height: 1.3;">${market ? market.title : 'Market Details'}</div>
                        <div style="font-size: 0.8rem; color: #f59e0b; margin-top: 5px;">üìä MULTI-OUTCOME MARKET</div>
                        <div style="font-size: 0.7rem; color: #64748b; margin-top: 2px;">Updated: ${timestamp}</div>
                    </div>
                    
                    <div style="background-color: #0f172a; border-radius: 6px; padding: 15px; text-align: center;">
                        <div style="color: #f59e0b; font-weight: bold; margin-bottom: 8px;">üéØ Multiple Choice Market</div>
                        <div style="color: #94a3b8; font-size: 0.9rem; line-height: 1.4;">
                            This market has multiple possible outcomes (not just YES/NO).<br>
                            Each outcome has its own probability and pricing.<br>
                            Check the main Kalshi platform for detailed outcome pricing.
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #334155;">
                            <div style="color: #10b981; font-size: 0.8rem;">üí° TIP: Use search to find binary (YES/NO) markets for clearer orderbook data</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Calculate market analytics for binary markets
            const analytics = calculateMarketAnalytics(data, market);
            
            detailEl.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;">${data.market_ticker}</div>
                    <div style="font-weight: bold; line-height: 1.3;">${market ? market.title : 'Market Details'}</div>
                    <div style="font-size: 0.8rem; color: #10b981; margin-top: 5px;">üî¥ LIVE DATA</div>
                    <div style="font-size: 0.7rem; color: #64748b; margin-top: 2px;">Updated: ${timestamp}</div>
                </div>
                
                ${analytics.html}
                
                <div class="section-title">Order Book</div>
                <div class="orderbook">
                    <div class="orderbook-side">
                        <div class="orderbook-header yes-header">YES</div>
                        ${formatOrderbookSide(data.yes, 'yes')}
                    </div>
                    <div class="orderbook-side">
                        <div class="orderbook-header no-header">NO</div>
                        ${formatOrderbookSide(data.no, 'no')}
                    </div>
                </div>
            `;
        }
        
        // Detect if this is a multi-outcome market
        function detectMultiOutcomeMarket(orderbookData, market) {
            const yesOrders = orderbookData.yes || [];
            const noOrders = orderbookData.no || [];
            
            // Check for telltale signs of multi-outcome markets
            const hasNoMeaningfulOrders = yesOrders.length === 0 && noOrders.length === 0;
            const hasOnlyLowPriceOrders = [...yesOrders, ...noOrders].every(order => order[0] < 5);
            
            // Check ticker patterns that suggest multi-outcome
            const ticker = market?.ticker || '';
            const title = market?.title || '';
            const isArtistMarket = ticker.includes('ARTIST') || title.toLowerCase().includes('artist');
            const isSportsPlayerMarket = ticker.includes('MVP') || ticker.includes('WINNER') || title.toLowerCase().includes('winner');
            const isElectionCandidate = title.toLowerCase().includes('candidate') && !title.toLowerCase().includes('will');
            
            return hasNoMeaningfulOrders || hasOnlyLowPriceOrders || isArtistMarket || isSportsPlayerMarket || isElectionCandidate;
        }
        
        // Calculate market analytics
        function calculateMarketAnalytics(orderbookData, market) {
            const yesOrders = orderbookData.yes || [];
            const noOrders = orderbookData.no || [];
            
            // Find best prices (highest YES bid, highest NO bid)
            const bestYesBid = yesOrders.length > 0 ? Math.max(...yesOrders.map(order => order[0])) : 0;
            const bestNoBid = noOrders.length > 0 ? Math.max(...noOrders.map(order => order[0])) : 0;
            
            // Calculate implied probability and spread
            const impliedYesPrice = bestYesBid;
            const impliedNoPrice = bestNoBid;
            const totalImplied = impliedYesPrice + impliedNoPrice;
            
            // Market volume and interest
            const yesVolume = yesOrders.reduce((sum, order) => sum + order[1], 0);
            const noVolume = noOrders.reduce((sum, order) => sum + order[1], 0);
            const totalVolume = yesVolume + noVolume;
            
            // Market maker analysis
            const yesLiquidity = yesOrders.filter(order => order[0] >= 10).reduce((sum, order) => sum + order[1], 0);
            const noLiquidity = noOrders.filter(order => order[0] >= 10).reduce((sum, order) => sum + order[1], 0);
            
            const html = `
                <div style="margin-bottom: 15px; background-color: #0f172a; border-radius: 6px; padding: 12px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 0.85rem;">
                        <div>
                            <div style="color: #10b981; font-weight: bold;">Market Price</div>
                            <div style="color: #f1f5f9;">YES: ${formatPrice(impliedYesPrice)} (${((impliedYesPrice/100)*100).toFixed(1)}%)</div>
                            <div style="color: #f1f5f9;">NO: ${formatPrice(impliedNoPrice)} (${((impliedNoPrice/100)*100).toFixed(1)}%)</div>
                        </div>
                        <div>
                            <div style="color: #10b981; font-weight: bold;">Volume</div>
                            <div style="color: #f1f5f9;">Total: ${totalVolume.toLocaleString()}</div>
                            <div style="color: #f1f5f9;">YES: ${yesVolume.toLocaleString()} | NO: ${noVolume.toLocaleString()}</div>
                        </div>
                    </div>
                    ${totalImplied > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #334155; font-size: 0.8rem; color: #94a3b8;">
                        Spread: ${formatPrice(Math.abs(100 - totalImplied))} ‚Ä¢ Liquidity: ${(yesLiquidity + noLiquidity).toLocaleString()} shares
                    </div>` : ''}
                </div>
            `;
            
            return {
                bestYesBid,
                bestNoBid,
                totalVolume,
                html
            };
        }
        
        // Initialize on page load
        window.addEventListener('load', function() {
            loadData();
            connectWebSocket();
            
            // Set up search and filter event listeners
            const searchInput = document.getElementById('market-search');
            const filterButtons = document.querySelectorAll('.filter-btn');
            
            // Search input
            searchInput.addEventListener('input', function() {
                currentSearch = this.value;
                filterMarkets();
            });
            
            // Filter buttons
            filterButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active button
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update filter and refresh
                    currentFilter = this.dataset.filter;
                    filterMarkets();
                });
            });
        });
        
        // Auto-refresh REST data every 30 seconds (WebSocket provides real-time updates)
        setInterval(loadData, 30000);
    </script>
</body>
</html>