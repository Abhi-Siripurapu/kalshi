<!DOCTYPE html>
<html>
<head>
    <title>Market Selection Debug</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #0f172a; color: #f1f5f9; }
        .debug { background: #1e293b; padding: 10px; margin: 10px 0; border-radius: 6px; }
        button { background: #4f46e5; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin: 5px; }
    </style>
</head>
<body>
    <h2>Market Selection Debug Test</h2>
    
    <button onclick="testMarketSelection()">Test Market Selection</button>
    <button onclick="testAPIs()">Test APIs Directly</button>
    
    <div id="debug" class="debug">Ready to test...</div>
    
    <script>
        const API_BASE = 'http://localhost:8000';
        
        async function testAPIs() {
            const debugEl = document.getElementById('debug');
            debugEl.innerHTML = 'Testing APIs...';
            
            try {
                // Test markets API
                const marketsResponse = await fetch(`${API_BASE}/markets?limit=1`);
                const marketsData = await marketsResponse.json();
                const ticker = marketsData.markets[0].ticker;
                
                debugEl.innerHTML += `<br>‚úÖ Markets API: ${ticker}`;
                
                // Test orderbook API
                const orderbookResponse = await fetch(`${API_BASE}/market/${ticker}/orderbook`);
                const orderbookData = await orderbookResponse.json();
                
                debugEl.innerHTML += `<br>‚úÖ Orderbook API: ${orderbookData.orderbook ? 'Working' : 'No data'}`;
                
                // Test candlesticks API
                const candleResponse = await fetch(`${API_BASE}/market/${ticker}/candlesticks?period_interval=60&start_days_ago=7`);
                const candleData = await candleResponse.json();
                
                debugEl.innerHTML += `<br>‚úÖ Candlesticks API: ${candleData.candlesticks ? candleData.candlesticks.length + ' periods' : 'No data'}`;
                
            } catch (err) {
                debugEl.innerHTML += `<br>‚ùå API Error: ${err.message}`;
            }
        }
        
        async function testMarketSelection() {
            const debugEl = document.getElementById('debug');
            debugEl.innerHTML = 'Testing market selection flow...';
            
            try {
                // Step 1: Get a market
                const marketsResponse = await fetch(`${API_BASE}/markets?limit=1`);
                const marketsData = await marketsResponse.json();
                const ticker = marketsData.markets[0].ticker;
                
                debugEl.innerHTML += `<br>üìä Selected ticker: ${ticker}`;
                
                // Step 2: Test orderbook loading
                debugEl.innerHTML += `<br>üìã Loading orderbook...`;
                const orderbookResponse = await fetch(`${API_BASE}/market/${ticker}/orderbook`);
                const orderbookData = await orderbookResponse.json();
                const orderbook = orderbookData.orderbook;
                
                debugEl.innerHTML += `<br>‚úÖ Orderbook loaded: YES orders = ${orderbook.yes?.length || 0}, NO orders = ${orderbook.no?.length || 0}`;
                
                // Step 3: Test candlestick loading
                debugEl.innerHTML += `<br>üìà Loading candlesticks...`;
                const candleResponse = await fetch(`${API_BASE}/market/${ticker}/candlesticks?period_interval=60&start_days_ago=7`);
                const candleData = await candleResponse.json();
                
                if (candleData.candlesticks && candleData.candlesticks.length > 0) {
                    debugEl.innerHTML += `<br>‚úÖ Candlesticks loaded: ${candleData.candlesticks.length} periods`;
                    
                    // Step 4: Test analytics functions
                    debugEl.innerHTML += `<br>üîç Testing analytics...`;
                    
                    // Test VWAP calculation
                    const vwapData = calculateVWAP(candleData.candlesticks);
                    debugEl.innerHTML += `<br>‚úÖ VWAP calculated: ${vwapData.length} points`;
                    
                    // Test movement detection
                    const movements = detectPriceMovements(candleData.candlesticks);
                    debugEl.innerHTML += `<br>‚úÖ Movements detected: ${movements.alerts.length} alerts`;
                    
                    // Test volume profile
                    const volumeProfile = calculateVolumeProfile(candleData.candlesticks);
                    debugEl.innerHTML += `<br>‚úÖ Volume profile: ${volumeProfile.profile.length} price levels`;
                    
                } else {
                    debugEl.innerHTML += `<br>‚ùå No candlestick data available`;
                }
                
                debugEl.innerHTML += `<br><br>üéâ All tests completed successfully!`;
                
            } catch (err) {
                debugEl.innerHTML += `<br>‚ùå Test failed: ${err.message}`;
                console.error('Test error:', err);
            }
        }
        
        // Copy analytics functions from main UI for testing
        function calculateVWAP(candlesticks) {
            let cumulativeVolumePrice = 0;
            let cumulativeVolume = 0;
            const vwapData = [];
            
            for (let i = 0; i < candlesticks.length; i++) {
                const candle = candlesticks[i];
                
                let typicalPrice;
                if (candle.price && candle.price.high !== null) {
                    const high = candle.price.high || candle.price.close;
                    const low = candle.price.low || candle.price.close;
                    const close = candle.price.close;
                    typicalPrice = (high + low + close) / 3;
                } else if (candle.yes_bid && candle.yes_ask) {
                    const bid = candle.yes_bid.close || candle.yes_bid.open;
                    const ask = candle.yes_ask.close || candle.yes_ask.open;
                    typicalPrice = (bid + ask) / 2;
                } else {
                    typicalPrice = candle.close || 50;
                }
                
                const volume = candle.volume || 0;
                cumulativeVolumePrice += typicalPrice * volume;
                cumulativeVolume += volume;
                
                const vwap = cumulativeVolume > 0 ? cumulativeVolumePrice / cumulativeVolume : typicalPrice;
                vwapData.push(vwap);
            }
            
            return vwapData;
        }
        
        function detectPriceMovements(candlesticks) {
            const movements = [];
            const alerts = [];
            
            for (let i = 1; i < candlesticks.length; i++) {
                const current = candlesticks[i];
                const previous = candlesticks[i - 1];
                
                let currentPrice, previousPrice;
                
                if (current.price && current.price.close !== null) {
                    currentPrice = current.price.close;
                } else {
                    currentPrice = 50;
                }
                
                if (previous.price && previous.price.close !== null) {
                    previousPrice = previous.price.close;
                } else {
                    previousPrice = 50;
                }
                
                const priceChange = currentPrice - previousPrice;
                const percentChange = previousPrice > 0 ? (priceChange / previousPrice) * 100 : 0;
                
                if (Math.abs(percentChange) >= 2) {
                    alerts.push({
                        type: percentChange > 0 ? 'spike' : 'drop',
                        message: `${Math.abs(percentChange).toFixed(1)}% movement`,
                        details: `${previousPrice.toFixed(1)}¬¢ ‚Üí ${currentPrice.toFixed(1)}¬¢`
                    });
                }
            }
            
            return { movements, alerts };
        }
        
        function calculateVolumeProfile(candlesticks) {
            const priceBuckets = {};
            
            candlesticks.forEach(candle => {
                let price = 50;
                if (candle.price && candle.price.close !== null) {
                    price = candle.price.close;
                }
                
                const volume = candle.volume || 0;
                const bucketPrice = Math.round(price);
                
                if (!priceBuckets[bucketPrice]) {
                    priceBuckets[bucketPrice] = 0;
                }
                priceBuckets[bucketPrice] += volume;
            });
            
            const profileData = Object.keys(priceBuckets).map(price => ({
                price: parseInt(price),
                volume: priceBuckets[price]
            }));
            
            return { profile: profileData };
        }
    </script>
</body>
</html>